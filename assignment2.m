%
%
%   Image Processing
%   Assignment 2
%   Sam Boles
%   03/03/2016
%
%   Takes two image files (CleanFingerprint.jpg, pacemaker.png) and locates
%   corner positions within the images
%
%   METHOD:
%   1.  Read in the images to variables
%   2.  Convert the images to matrices of doubles so they can be operated on
%   3.  Convert the matrices into greyscale values, call them P for the
%       pacemaker and F for the fingerprint
%   4.  Contrast stretch F and P by subtracting the min value divided by the
%       max - the min from each element of the matrices
%   5.  Create the sobel filter matrices SobelV for vertical edges and SobelH
%       for horizontal edges
%   6.  Convolute F with SobelH assign the result to FIx
%   7.  Convolute F with SobelV assign the result to FIy
%   8.  Convolute P with SobelH assign the result to PIx
%   9.  Convolute P with SobelV assign the result to PIy
%   10. Get the element wise squares of FIx and FIy and assign them to FIx2 and
%       FIy2 respectively
%   11. Get the element wise product of FIx and FIy and assign it to FIxy
%   12. Get the element wise squares of PIx and PIy and assign them to PIx2 and
%       PIy2 respectively
%   13. Get the element wise product of PIx and PIy and assign it to PIxy
%   14. Run a Gaussian filter on FIx2, FIy2, FIxy, PIx2, PIy2, PIxy
%   15. Get the height FH and the width FW of F
%   16. Get the height PH and the width PW of P
%   17. Set gam to be 0.04
%   18. Get the corner matrix for F, FC by elment wise multiplying FIx2 by FIy2
%       subtracting the element wise square of FIxy and then subtracting gam
%       multiplied by the elment wise square of FIx2 plus FIy2
%   19. Create a copy of FC
%   20. Remove a row of pixels from the top and bottom of FC and a col from both
%       sides, this is to get rid of the border generated by convolutuion and
%       prevent it from effecting the contrast stretch, variance and std of the
%       image later on
%   21. Contrast stretch FC
%   22. Get the corner matrix for P, PC by elment wise multiplying PIx2 by PIy2
%       subtracting the element wise square of PIxy and then subtracting gam
%       multiplied by the elment wise square of PIx2 plus PIy2
%   23. Get h and w as 10% of the height and width of PC respectively
%   24. Create PCMax as a copy of PC
%   24. For loop through the matrix PC
%   25. Take a cookie cut matrix of the elements h above and below and w in
%       each horizontal direction of the current element/pixel
%   26. Check if the current element is the max element in the cookie
%   27. If yes, then set PCMax for the current location to 1
%   28. If no, then set PCMax for the current location to 0
%   29. End the for loop
%   30. Create a copy of PC
%   31. Remove a row of pixels from the top and bottom of PC and a col from both
%       sides, this is to get rid of the border generated by convolutuion and
%       prevent it from effecting the contrast stretch, variance and std of the
%       image later on
%   32. Contrast stretch PC
%   33. Create threshold value for FC by taking the median value of FC plus the
%       standard deviation of FC
%   34. Change the copy of FC so that the elements apart from the border are
%       equal to FC (they have undergone contrast stretching and been used to
%       get the median and standard deviation), this is to ensure that the
%       matrices relating to fingerprint are all the same height and width
%   35. Make FC equal to the copy (the copy could just be used, but this feels
%       nicer)
%   36. Add the thresholded values of FC to the 1st layer (red layer) of the
%       original fingerprint doubles matrix image. This adds red dots to the
%       image where there are corners that passed the threshold
%   37. Create threshold value for PC by taking the median value of PC plus the
%       standard deviation of PC
%   38. Change the copy of PC so that the elements apart from the border are
%       equal to PC
%   39. Make PC equal to the copy
%   40. Make PC equal to the element wise multiplication of itself and PCMax,
%       this acts as a global filter that zeroes out any values that aren't
%       local maximums, allowing the selection of only the strongest corners.
%   41. Add the thresholded values of PC to the 1st layer (red layer) of the
%       original pacemaker doubles matrix image.
%   42. Display the fingerprint image in a subplot with the red dots
%   43. Display the pacemaker image in a subplot with the red dots
%
%
%   TESTING:
%     Tested against a number of similar images, works on most black and white
%     fingerprint images, has memory issues with higher details coloured ones.
%
%     Tested on both the given images, they both work.
%
%     Tested on images with words in them including the "CORNER" image with it
%     successfully detecting the corners.
%
%

clc;
clear all;
close all;

fingerprint = imread('CleanFingerprint.jpg');
pacemaker = imread('pacemaker.png');

Pm = im2double(pacemaker);
Fp = im2double(fingerprint);
P = rgb2gray(Pm);
F = rgb2gray(Fp);

P = (P - min(P(:)))./(max(P(:)) - min(P(:)));
F = (F - min(F(:)))./(max(F(:)) - min(F(:)));

SobelV = [1 0 -1;
          2 0 -2;
          1 0 -1;]/4;

SobelH = [1 2 1;
          0 0 0;
        -1 -2 -1;]/4;

FIx = conv2(F,SobelH, 'same');
FIy = conv2(F,SobelV, 'same');

PIx = conv2(P,SobelH, 'same');
PIy = conv2(P,SobelV, 'same');

FIx2 = FIx.^2;
FIy2 = FIy.^2;
FIxy = FIx.*FIy;

PIx2 = PIx.^2;
PIy2 = PIy.^2;
PIxy = PIx.*PIy;

FIx2 = conv2(FIx2, fspecial('Gaussian'), 'same');
FIy2 = conv2(FIy2, fspecial('Gaussian'), 'same');
FIxy = conv2(FIxy, fspecial('Gaussian'), 'same');

PIx2 = conv2(PIx2, fspecial('Gaussian'), 'same');
PIy2 = conv2(PIy2, fspecial('Gaussian'), 'same');
PIxy = conv2(PIxy, fspecial('Gaussian'), 'same');

[FH,FW] = size(F);
[PH,PW] = size(P);

gam = 0.04;

FC = (FIx2.*FIy2) - FIxy.^2 - (gam *(FIx2 + FIy2).^2);

FTempStore = FC;
FC = FC(2:FH-1,2:FW-1);

FC = (FC - min(FC(:)))./(max(FC(:)) - min(FC(:)));

PC = (PIx2.*PIy2) - PIxy.^2 - (gam *(PIx2 + PIy2).^2);

h = round(PH/10);
w = round(PW/10);
PCMax = PC;
for i = h+1:PH-h
    for j = w+1:PW-w
        Cookie = PC(i-h:i+h-1, j-w:j+w-1);
        if PC(i,j) == max(Cookie(:))
            PCMax(i,j) = 1;
        else
            PCMax(i,j) = 0;
        end
    end
end

PTempStore = PC;
PC = PC(2:PH-1,2:PW-1);

PC = (PC - min(PC(:)))./(max(PC(:)) - min(PC(:)));


threshold = median(FC(:)) + std(FC(:));
FTempStore(2:FH-1,2:FW-1) = FC(:,:);
FC=FTempStore;
Fp(:,:,1) = Fp(:,:,1) + (FC>threshold);

threshold = median(PC(:)) + std(PC(:));
PTempStore(2:PH-1,2:PW-1) = PC(:,:);
PC=PTempStore;
PC = PC.*PCMax;
Pm(:,:,1) = Pm(:,:,1) + (PC>threshold);

subplot(1,2,1), imshow(Fp), title('Fingerprint');
subplot(1,2,2), imshow(Pm), title('Pacemaker');
